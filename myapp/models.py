from django.db import modelsfrom django.utils import timezonefrom decimal import Decimalclass UserProfile(models.Model):    username = models.CharField(max_length=20, unique=True)    user_firstname = models.CharField(max_length=30, unique=False, null = True)    wallet = models.DecimalField(max_digits=20, decimal_places=2, default=0)    invited_by = models.TextField(null=True, blank=True)    users_invited = models.TextField(default="", null=True, blank=True)    highest_invited_wallets_sum = models.DecimalField(max_digits=20, decimal_places=2, default=0)    last_daily_bonus = models.DateTimeField(null=True, blank=True)    recieved_threefriends_reward = models.BooleanField(default=False)    last_12h_task_1 = models.DateTimeField(null=True, blank=True)    last_12h_task_2 = models.DateTimeField(null=True, blank=True)    taskyt_status = models.BooleanField(default=True)    telegram_rewards = models.TextField(default="", null=True, blank=True)    joined = models.DateTimeField(auto_now_add=True)  # Automatically set on creation    last_online = models.DateTimeField(null=True, blank=True)    def __str__(self):        return self.username    def check_level_up(self):        level_requirements = {            2: 50000,            3: 100000,            4: 500000,            5: 1000000,            6: 5000000,            7: 10000000,            8: 50000000,            9: 100000000,            10: 1000000000,        }        next_level = self.level + 1        if next_level in level_requirements and self.wallet >= level_requirements[next_level]:            self.level = next_level            self.tap_efficiency += 1            self.energy += 500            self.save()            return True        return False    def get_depth_lists(self):        # Initialize the lists for each depth level        depth_lists = [[] for _ in range(6)]        # Start the recursive calculation        invited_usernames = [username.strip() for username in self.users_invited.split(',') if username.strip()]        self._calculate_recursive_lists(invited_usernames, depth=6, lists=depth_lists)        return depth_lists        # Initialize the lists for each depth level        depth_lists = [[] for _ in range(6)]        # Start the recursive calculation        invited_usernames = [username.strip() for username in self.users_invited.split(',') if username.strip()]        self._calculate_recursive_lists(invited_usernames, depth=6, lists=depth_lists)        # Calculate the total bonus based on the lists        total_bonus = Decimal('0.00')        bonus_percentages = {            1: Decimal('0.40'),            2: Decimal('0.20'),            3: Decimal('0.10'),            4: Decimal('0.05'),            5: Decimal('0.02'),            6: Decimal('0.01'),        }        for i, level_list in enumerate(depth_lists):            if level_list:                users = UserProfile.objects.filter(username__in=level_list)                total_bonus += sum(user.wallet * bonus_percentages[i + 1] for user in users)        if total_bonus > self.highest_invited_wallets_sum:            self.highest_invited_wallets_sum = total_bonus            self.save()        return total_bonus    def _calculate_recursive_lists(self, usernames, depth, lists):        if depth == 0:            return        # Add current usernames to the appropriate depth list        lists[6 - depth].extend(usernames)        # Get the next level of invited users        next_level_users = UserProfile.objects.filter(username__in=usernames)        next_level_usernames = []        for user in next_level_users:            next_level_usernames.extend([u.strip() for u in user.users_invited.split(',') if u.strip()])        # Recur for the next level        self._calculate_recursive_lists(next_level_usernames, depth - 1, lists)    def calculate_bonus(self):        if not self.users_invited:            return Decimal('0.00')class Category(models.Model):    name = models.CharField(max_length=50)    def __str__(self):        return self.nameclass Task(models.Model):    name = models.CharField(max_length=50, unique=True)    picture = models.ImageField(upload_to='myapp/static/task_pictures/')    cost = models.DecimalField(max_digits=10, decimal_places=2)    link = models.URLField(max_length=200, blank=True, null=True)    def __str__(self):        return self.nameclass TaskUser(models.Model):    STATUSES = [        (1, 'Start'),        (2, 'Claim'),        (3, 'Done'),    ]    user = models.ForeignKey(UserProfile, on_delete=models.CASCADE)    task = models.ForeignKey(Task, on_delete=models.CASCADE)    status = models.IntegerField(choices=STATUSES, default=1)    def __str__(self):        return f"{self.user.username} - {self.task.name}"    def status_change(self):        self.status = (self.status % 3) + 1        self.save()class Task_Timer(models.Model):    name = models.CharField(max_length=50, unique=True)    picture = models.ImageField(upload_to='myapp/static/task_pictures/')    cost = models.DecimalField(max_digits=10, decimal_places=2)    link = models.URLField(max_length=200, blank=True, null=True)    def __str__(self):        return self.nameclass TaskUser_Timer(models.Model):    STATUSES = [        (1, 'Start'),        (2, 'Claim'),        (3, 'Done'),    ]    user = models.ForeignKey(UserProfile, on_delete=models.CASCADE)    task = models.ForeignKey(Task, on_delete=models.CASCADE)    status = models.IntegerField(choices=STATUSES, default=1)    timer = models.DateTimeField(null=True, blank=True)    def __str__(self):        return f"{self.user.username} - {self.task.name}"    def status_change(self):        self.status = (self.status % 3) + 1        self.save()class Telegram_Sub_Tasks(models.Model):    chat_id = models.CharField(max_length=50)    url = models.URLField(max_length=200, blank=True, null=True)