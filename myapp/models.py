from django.db import modelsfrom django.utils import timezoneimport uuidclass UserProfile(models.Model):    LEVELS = [        (1, 'Bronze'),        (2, 'Silver'),        (3, 'Gold'),        (4, 'Platinum'),        (5, 'Diamond'),        (6, 'Master'),        (7, 'Grandmaster'),        (8, 'Elite'),        (9, 'Legendary'),        (10, 'The King'),    ]    username = models.CharField(max_length=20, unique=True)    wallet = models.DecimalField(max_digits=20, decimal_places=2, default=1)    level = models.IntegerField(default=1)    energy = models.IntegerField(default=1000)    energy_limit = models.IntegerField(default=1000)    multitap_level = models.IntegerField(default=1)    tap_efficiency = models.IntegerField(default=1)    energy_limit_level = models.IntegerField(default=1)    last_energy_update = models.DateTimeField(default=timezone.now)    invited_by = models.TextField(null=True, blank=True)    users_invited = models.TextField(default="", null=True, blank=True)    highest_invited_wallets_sum = models.DecimalField(max_digits=20, decimal_places=2, default=0)    last_daily_bonus = models.DateTimeField(null=True, blank=True)    daily_energy_last_daily_bonus = models.DateTimeField(null=True, blank=True)    daily_turbo_last_daily_bonus = models.DateTimeField(null=True, blank=True)    last_mining_bonus = models.DateTimeField(null=True, blank=True)    def __str__(self):        return self.username    def check_level_up(self):        level_requirements = {            2: 50000,            3: 100000,            4: 500000,            5: 1000000,            6: 5000000,            7: 10000000,            8: 50000000,            9: 100000000,            10: 1000000000,        }        next_level = self.level + 1        if next_level in level_requirements and self.wallet >= level_requirements[next_level]:            self.level = next_level            self.tap_efficiency += 1            self.energy += 500            self.save()            return True        return False    def regenerate_energy(self):        now = timezone.now()        elapsed_seconds = (now - self.last_energy_update).total_seconds()        new_energy = self.energy + int(elapsed_seconds)        # Calculate energy limit based on energy_limit_level        self.energy_limit = (1000 + (self.energy_limit_level - 1) * 500 + (self.level * 500))        if new_energy > self.energy_limit:            new_energy = self.energy_limit        self.energy = new_energy        self.last_energy_update = now        self.save()    def set_energy_to_limit(self):        """Sets the energy value to the energy_limit value."""        self.energy = self.energy_limit        self.save()    @property    def max_energy_level_reached(self):        return self.energy_limit_level >= 20    @property    def next_energy_level(self):        return min(self.energy_limit_level, 20)    def _calculate_recursive_bonus(self, usernames, depth):        if depth == 0 or not usernames:            return 0        # Define the percentage for each depth level        bonus_percentages = {            1: 0.40,            2: 0.20,            3: 0.10,            4: 0.05,            5: 0.02,            6: 0.01,        }        invited_users = UserProfile.objects.filter(username__in=usernames)        total_bonus = sum(user.wallet * bonus_percentages[depth] for user in invited_users)        next_level_usernames = []        for user in invited_users:            if user.users_invited:                next_level_usernames.extend(                    [username.strip() for username in user.users_invited.split(',') if username.strip()]                )        total_bonus += self._calculate_recursive_bonus(next_level_usernames, depth - 1)        return total_bonus    def _calculate_recursive_bonus(self, usernames, depth):        if depth == 0 or not usernames:            return 0        # Define the percentage for each depth level        bonus_percentages = {            1: 0.40,            2: 0.20,            3: 0.10,            4: 0.05,            5: 0.02,            6: 0.01,        }        invited_users = UserProfile.objects.filter(username__in=usernames)        total_bonus = sum(user.wallet * bonus_percentages[depth] for user in invited_users)        next_level_usernames = []        for user in invited_users:            if user.users_invited:                next_level_usernames.extend(                    [username.strip() for username in user.users_invited.split(',') if username.strip()]                )        total_bonus += self._calculate_recursive_bonus(next_level_usernames, depth - 1)        return total_bonus    def calculate_bonus(self):        if not self.users_invited:            return 0        invited_usernames = [username.strip() for username in self.users_invited.split(',') if username.strip()]        total_bonus = self._calculate_recursive_bonus(invited_usernames, depth=6)        if total_bonus > self.highest_invited_wallets_sum:            self.highest_invited_wallets_sum = total_bonus            self.save()            return total_bonus - self.highest_invited_wallets_sum        return 0    def apply_bonus(self):        bonus = self.calculate_bonus()        if bonus > 0:            self.wallet += bonus            self.save()        return bonusclass Category(models.Model):    name = models.CharField(max_length=50)    def __str__(self):        return self.nameclass Task(models.Model):    name = models.CharField(max_length=50, unique=True)    picture = models.ImageField(upload_to='myapp/static/task_pictures/')    cost = models.DecimalField(max_digits=10, decimal_places=2)    link = models.URLField(max_length=200, blank=True, null=True)    def __str__(self):        return self.nameclass TaskUser(models.Model):    STATUSES = [        (1, 'Start'),        (2, 'Claim'),        (3, 'Done'),    ]    user = models.ForeignKey(UserProfile, on_delete=models.CASCADE)    task = models.ForeignKey(Task, on_delete=models.CASCADE)    status = models.IntegerField(choices=STATUSES, default=1)    def __str__(self):        return f"{self.user.username} - {self.task.name}"    def status_change(self):        self.status = (self.status % 3) + 1        self.save()